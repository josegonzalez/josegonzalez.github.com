<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jose Diaz-Gonzalez</title>
    <description>Developer, Accidental Ops Guy, and CakePHP Core Developer</description>
    <link>http://josediazgonzalez.com/</link>
    <atom:link href="http://josediazgonzalez.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 18 Dec 2015 00:58:09 +0000</pubDate>
    <lastBuildDate>Fri, 18 Dec 2015 00:58:09 +0000</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>CakePHP Shells I didn&#39;t know about</title>
        <description>&lt;p&gt;Did you know there is a shell that allows you to enable a plugin after installing it via composer?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/cake plugin load Muffin/Trash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also load the plugin’s bootstrap or routes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# I&#39;m not releasing this, so don&#39;t try and composer require it
bin/cake plugin load --bootstrap --routes Josegonzalez/Blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most people installed CakePHP 3 using the &lt;a href=&quot;http://josediazgonzalez.com/2015/12/09/customizing-your-app-template/&quot;&gt;&lt;code&gt;cakephp/app&lt;/code&gt; project template&lt;/a&gt;, so you have access to both &lt;code&gt;bake&lt;/code&gt; and &lt;code&gt;migrations&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# migrate all the things!
bin/cake migrations migrate

# get a migration status
bin/cake migrations status

# bake a migration
bin/cake bake migration_snapshot Initial

# bake a form (or really anything else)
bin/cake bake form AddForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are running migrations, it may be useful to clear the ORM’s cache so that your code is aware of the new fields:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/cake migrations migrate &amp;amp;&amp;amp; bin/cake orm_cache clear
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if you are deploying code, maybe you want to ensure the cache is set &lt;em&gt;before&lt;/em&gt; the first user’s request comes in, speeding up that initial request:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/cake orm_cache build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’m a big fan of the &lt;code&gt;server&lt;/code&gt; shell. It allows me to quickly test an app locally without needing to setup a virtualhost or a webserver. Very useful for development, and something I recommend everyone learn to place in their arsenal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# specify a port I know won&#39;t collide with other stuff I run on my machine
bin/cake server -p 1995
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In older versions of CakePHP 3, we introduced a full REPL around &lt;a href=&quot;https://github.com/borisrepl/boris&quot;&gt;boris&lt;/a&gt;, but that has since been replaced with &lt;a href=&quot;http://psysh.org/&quot;&gt;Psysh&lt;/a&gt;. It’s actually quite nice, and lets me test out new code I’ve written in various scenarios.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# yo dawg, i hurd u liek shells, so I put a shell in your shell so you can shell while you shell!
bin/cake console
# Note: it saves your history, just like a regular shell, which is nice :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, something I missed from my short stint doing Ruby on Rails, being able to list routes in an application.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# list routes
bin/cake routes

# see what a url route maps to internally
bin/cake routes check /articles

# generate the url route for a key:pair setup
bin/cake routes generate controller:Articles action:view 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bonus&quot;&gt;Bonus!&lt;/h2&gt;

&lt;p&gt;A shell I discovered a few weeks back is one by the ever-helpful &lt;a href=&quot;https://www.loadsys.com/&quot;&gt;Loadsys Web Strategies&lt;/a&gt; company. It lets you read into keys were loaded into configure (which is great if you have an app with several &lt;code&gt;Configure::load()&lt;/code&gt; statements and don’t know where a key might be):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# install it
composer require loadsys/cakephp-config-read:~3.0

# load it
bin/cake plugin load ConfigRead

# use it (on your debug mode)
bin/cake config_read debug

# on your application&#39;s encoding
bin/cake config_read App.encoding

# on the default database configuration
bin/cake config_read Datasources.default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is there a CakePHP Shell you’d like to see ported from another framework? Something you find useful or lacking? Leave a note in the comments.&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/17/cakephp-shells-i-didnt-know-about/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/17/cakephp-shells-i-didnt-know-about/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>shells</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Custom Validation Rule Classes</title>
        <description>&lt;p&gt;I was asked yesterday if I could elaborate on my &lt;code&gt;OwnedByCurrentUser&lt;/code&gt; rule class. I’ll post it here, but also post on my process for developing rules.&lt;/p&gt;

&lt;h2 id=&quot;organization&quot;&gt;Organization&lt;/h2&gt;

&lt;p&gt;First off, I &lt;em&gt;hate&lt;/em&gt; having anonymous functions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They are harder to test in isolation of the enclosing scope.&lt;/li&gt;
  &lt;li&gt;They make it more difficult to reason about classes because of the implicit extra scope/binding of the callable.&lt;/li&gt;
  &lt;li&gt;I think they look silly.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I definitely think they have their place - configuring the CRUD Plugin is one - but normally I try to stay away from them if possible. Instead, I use &lt;a href=&quot;/2015/12/06/invoking-callable-classes/&quot;&gt;invokable callable classes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For rules, I normally place my callable classes in &lt;code&gt;src/Form/Rule&lt;/code&gt;. Here is what our initial &lt;code&gt;OwnedByCurrentUser&lt;/code&gt; rule looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Form\Rule;
class OwnedByCurrentUser
{
    /**
     * Performs the check
     *
     * @param mixed $value The data to validate
     * @param array $context A key value list of data that could be used as context
     * during validation. Recognized keys are:
     * - newRecord: (boolean) whether or not the data to be validated belongs to a
     *   new record
     * - data: The full data that was passed to the validation process
     * - field: The name of the field that is being processed
     * - providers: associative array with objects or class names that will
     *   be passed as the last argument for the validation method
     * @return bool
     */
    public function __invoke($value, array $context = null)
    {
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;filling-it-in&quot;&gt;Filling it in&lt;/h2&gt;

&lt;p&gt;When I write a rule, I’ll first write it to handle one very specific case. In this particular application, I had to ensure that a particular &lt;code&gt;Battle&lt;/code&gt; was owned by a participant in the battle before allowing them to perform certain actions. My invoke looked like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function __invoke($value, array $context = null)
{
    $table = \Cake\ORM\TableRegistry::get(&#39;Battles&#39;);
    return !!$table-&amp;gt;find()-&amp;gt;where([
      &#39;id&#39; =&amp;gt; (int)$value,
      &#39;user_id&#39; =&amp;gt; $userId,
    ])-&amp;gt;firstOrFail();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above sort of works:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It actually throws a &lt;code&gt;Cake\Datasource\Exception\RecordNotFoundException&lt;/code&gt; exception, which is incorrect for my use case, since I don’t want validation rules to throw exceptions&lt;/li&gt;
  &lt;li&gt;I wasn’t sure where I was passing in the &lt;code&gt;$userId&lt;/code&gt;. The &lt;code&gt;$context&lt;/code&gt; maybe?&lt;/li&gt;
  &lt;li&gt;I’m offloading a lot of logic into the database. What if I don’t have compound index on &lt;code&gt;id/user_id&lt;/code&gt;? That would slow down this part of the app (maybe not a concern).&lt;/li&gt;
  &lt;li&gt;There was a table where I was thinking of re-using this in the near future that used &lt;code&gt;creator_id&lt;/code&gt; instead of &lt;code&gt;user_id&lt;/code&gt; to denote who owned the record (legacy applications, am I right?). This was hardcoded to the one field, which would mean more copy-pasting. I also couldn’t modify the table that was being checked. Boo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once I had a few tests going that brought up the above issues, I knew I had to refactor it.&lt;/p&gt;

&lt;h2 id=&quot;fixing-issues&quot;&gt;Fixing issues&lt;/h2&gt;

&lt;p&gt;I took a step back and realized I wanted to instantiate rules and then invoke them several times. This meant modifying the rule instance state, as well as passing in an initial state. First, lets add a constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;protected $_alias;
protected $_userId;
protected $_fieldName;

/**
 * Performs the check
 *
 * @param string $alias Table alias
 * @param mixed $userId A string or integer denoting a user&#39;s id
 * @param string $fieldName A name to use when checking an entity&#39;s association
 * @return void
 */
public function __construct($alias, $userId, $fieldName = &#39;user_id&#39;)
{
    $this-&amp;gt;_alias = $alias;
    $this-&amp;gt;_userId = $userId;
    $this-&amp;gt;_fieldName = $fieldName;
}

public function setTable($alias)
{
    $this-&amp;gt;_alias = $alias;
}

public function setUserId($userId)
{
    $this-&amp;gt;_userId = $userId;
}

public function setFieldName($fieldName)
{
    $this-&amp;gt;_fieldName = $fieldName;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each field is a protected field - meaning I can extend this easily by subclassing - and all have setters - meaning I can reuse a rule instance if necessary. Next I needed to modify the &lt;code&gt;__invoke()&lt;/code&gt; method to use my customizations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function __invoke($value, array $context = null)
{
    // handle the case where no userId was
    // specified or the user is logged out
    $userId = $this-&amp;gt;_userId;
    if (empty($userId)) {
        return false;
    }

    // use the Table class specified by our configured alias
    $table = \Cake\ORM\TableRegistry::get($this-&amp;gt;_alias);

    // Don&#39;t make the database do the heavy-lifting
    $entity = $table-&amp;gt;find()-&amp;gt;where([&#39;id&#39; =&amp;gt; (int)$value])-&amp;gt;first();
    if (empty($entity)) {
        return false;
    }

    // Ensure any customized field matches our userId
    return $entity-&amp;gt;get($this-&amp;gt;_fieldName) == $userId;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;wrapping-it-up&quot;&gt;Wrapping it up&lt;/h3&gt;

&lt;p&gt;From yesterday’s post, here is how the rule is invoked:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;protected function _buildValidator(Validator $validator)
{
    // use $this-&amp;gt;_user in my validation rules
    $userId = $this-&amp;gt;_user-&amp;gt;get(&#39;id&#39;);
    $validator-&amp;gt;add(&#39;id&#39;, &#39;custom&#39;, [
        &#39;rule&#39; =&amp;gt; function ($value, $context) use ($userId) {
            // reusing an invokable class
            $rule = new OwnedByCurrentUser(&#39;Battles&#39;, $userId);
            return $rule($value, $context);
        },
        &#39;message&#39; =&amp;gt; &#39;This photo isn\&#39;t yours to battle with&#39;
    ]);

    // This should also work
    $validator-&amp;gt;add(&#39;id&#39;, &#39;custom&#39;, [
        &#39;rule&#39; =&amp;gt; new OwnedByCurrentUser(&#39;Battles&#39;, $userId),
        &#39;message&#39; =&amp;gt; &#39;This photo isn\&#39;t yours to battle with&#39;
    ]);

    // As should this (and you can now re-use the rule)
    $rule = new OwnedByCurrentUser(&#39;Battles&#39;, $userId);
    $validator-&amp;gt;add(&#39;id&#39;, &#39;custom&#39;, [
        &#39;rule&#39; =&amp;gt; $rule,
        &#39;message&#39; =&amp;gt; &#39;This photo isn\&#39;t yours to battle with&#39;
    ]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mopping-up&quot;&gt;Mopping up&lt;/h2&gt;

&lt;p&gt;When I first found out I could do this, I was quite delighted by it. Validation rules have always been a pain to test, and this was as good as it got. I now have an easy to understand class that is both easily testable and gives me increased code reuse.&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/16/custom-validation-rule-classes/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/16/custom-validation-rule-classes/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>rules</category>
        
        <category>validation</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Stuffing Complex Logic into Model-less Forms</title>
        <description>&lt;p&gt;One new feature of CakePHP 3 is the ability to have &lt;a href=&quot;http://book.cakephp.org/3.0/en/core-libraries/form.html&quot;&gt;Model-less form classes&lt;/a&gt;. These are typically useful for stuff like contact forms that might send an email:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Form;

use Cake\Form\Form;
use Cake\Form\Schema;
use Cake\Mailer\Email;
use Cake\Validation\Validator;

class ContactForm extends Form
{
    // require some data
    protected function _buildSchema(Schema $schema)
    {
        return $schema-&amp;gt;addField(&#39;name&#39;, &#39;string&#39;)
            -&amp;gt;addField(&#39;email&#39;, [&#39;type&#39; =&amp;gt; &#39;string&#39;])
            -&amp;gt;addField(&#39;body&#39;, [&#39;type&#39; =&amp;gt; &#39;text&#39;]);
    }

    // validate the incoming data
    protected function _buildValidator(Validator $validator)
    {
        return $validator-&amp;gt;add(&#39;name&#39;, &#39;length&#39;, [
                &#39;rule&#39; =&amp;gt; [&#39;minLength&#39;, 10],
                &#39;message&#39; =&amp;gt; &#39;A name is required&#39;
            ])-&amp;gt;add(&#39;email&#39;, &#39;format&#39;, [
                &#39;rule&#39; =&amp;gt; &#39;email&#39;,
                &#39;message&#39; =&amp;gt; &#39;A valid email address is required&#39;,
            ]);
    }

    // actually send an email
    protected function _execute(array $data)
    {
        $email = new Email(&#39;default&#39;);
        return $email-&amp;gt;from([$data[&#39;email&#39;] =&amp;gt; $data[&#39;name&#39;]])
            -&amp;gt;to(&#39;mail@example.com&#39;, &#39;Mail Example&#39;)
            -&amp;gt;subject(&#39;Contact Form&#39;)
            -&amp;gt;message($data[&#39;body&#39;])
            -&amp;gt;send();
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neato burrito. One thing I love about this is the ability to have complex validation rulesets for specific actions. For instance, on a blog, I might have complex edit action that needs to check for editing writes before allowing a user to do anything:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Form;

use Cake\Form\Form;

class PostEditForm
{
    protected $_user = null;
    public function __construct(array $user = [])
    {
        $this-&amp;gt;_user = $user;
        return $this;
    }

    protected function _buildValidator(Validator $validator)
    {
      // use $this-&amp;gt;_user in my validation rules
      $userId = $this-&amp;gt;_user-&amp;gt;get(&#39;id&#39;);
      $validator-&amp;gt;add(&#39;id&#39;, &#39;custom&#39;, [
          &#39;rule&#39; =&amp;gt; function ($value, $context) use ($userId) {
              // reusing an invokable class
              return (new OwnedByCurrentUser($userId))-&amp;gt;__invoke($value);
          },
          &#39;message&#39; =&amp;gt; &#39;This photo isn\&#39;t yours to battle with&#39;
      ]);
    }
  }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nifty, huh? Usually I end up saving new records in my &lt;code&gt;_execute()&lt;/code&gt; method as well. Here is what that looks like in one of my form classes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;protected function _execute(array $data)
{
    $battle_id = Hash::get($data, &#39;id&#39;, null);
    $photo_id = Hash::get($data, &#39;photo_id&#39;, null);
    $battles = TableRegistry::get(&#39;Battles&#39;);
    $photos = TableRegistry::get(&#39;Photos&#39;);

    $battle = $battles-&amp;gt;find(&#39;Battle&#39;, [
        &#39;battle_id&#39; =&amp;gt; $battle_id,
    ])-&amp;gt;firstOrFail();

    if ($battle-&amp;gt;confirmed != null) {
        throw new MethodNotAllowedException(&#39;Battle has already been updated&#39;);
    }

    $photo = $photos-&amp;gt;get($photo_id);

    $battle-&amp;gt;confirmed = true;
    $battle-&amp;gt;rival-&amp;gt;photo = $photo;
    if ($battles-&amp;gt;save($battle)) {
        return $battles-&amp;gt;find(&#39;Battle&#39;, $battle-&amp;gt;toFind())-&amp;gt;firstOrFail();
    }

    $exception = new ValidationException(&#39;There are errors in the data you submitted&#39;);
    $exception-&amp;gt;errors($battle-&amp;gt;errors());
    throw $exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why? Because it turns certain complex actions into the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function edit()
{
    $authedUser = $this-&amp;gt;Auth-&amp;gt;user();
    $post = (new PostEditForm($authedUser))-&amp;gt;execute($this-&amp;gt;request-&amp;gt;data);
    $this-&amp;gt;set([&#39;post&#39; =&amp;gt; $post]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of litering logic across:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a custom validation method in my model&lt;/li&gt;
  &lt;li&gt;a controller action&lt;/li&gt;
  &lt;li&gt;some other random model method or protected controller method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I can group it all together into one, logical unit that can be easily unit tested for various types of input. A side-benefit of this is that if I &lt;em&gt;absolutely&lt;/em&gt; need to, I can always re-use a given action’s logic with as few as three lines of code within say, idk, a console shell.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/15/stuffing-complex-logic-into-model-less-forms/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/15/stuffing-complex-logic-into-model-less-forms/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>forms</category>
        
        <category>service</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Custom Logging Engines and adding Contextual Data</title>
        <description>&lt;p&gt;Logging is incredibly important, and are very useful for debugging misbehaving applications. CakePHP 3 implements the &lt;a href=&quot;https://github.com/php-fig/log&quot;&gt;PSR-3&lt;/a&gt; logging standard - specifically extending the &lt;a href=&quot;https://github.com/php-fig/log/blob/master/Psr/Log/AbstractLogger.php&quot;&gt;AbstractLogger&lt;/a&gt; - so you have all normal logging levels available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// the `Cake\Log\Log` class holds a log registry,
// so you don&#39;t need to instantiate new loggers constantly
Log::info(&#39;Some info level message&#39;);
Log::error(&#39;uh oh! an error&#39;);

// Swap out to Monolog because you need
// to ship/store logs a specific way
// In your bootstrap:
use Monolog\Logger;
use Monolog\Handler\StreamHandler;

// Configure the logger
Log::config(&#39;default&#39;, function () {
    $log = new Logger(&#39;app&#39;);
    $log-&amp;gt;pushHandler(new StreamHandler(&#39;path/to/your/combined.log&#39;));
    return $log;
});

// Drop unused loggers
Log::drop(&#39;debug&#39;);
Log::drop(&#39;error&#39;);
// and then use it as normal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You’ll notice that a few classes have their own &lt;code&gt;log&lt;/code&gt; methods. You can add this to your own classes using the &lt;code&gt;LogTrait&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App;

use Cake\Log\LogTrait;
class Foo {
  use LogTrait
  public function bar()
  {
    $this-&amp;gt;log(&#39;baz&#39;);
  }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One thing I like doing is having &lt;code&gt;Tagged&lt;/code&gt; logs. That is, I will write a log message like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Message is an entity WUT
// Entities are just bags of data, you can use them however you want
$message = new Message([
  &#39;message&#39; =&amp;gt; &#39;User logged in&#39;,
  &#39;user_id&#39; =&amp;gt; $user-&amp;gt;get(&#39;id&#39;),
  &#39;via&#39; =&amp;gt; &#39;android&#39;
]);

// :boom:
Log::info($message);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CakePHP’s internal formatter will automatically &lt;code&gt;json_encode&lt;/code&gt; any message that is &lt;code&gt;JsonSerializable&lt;/code&gt;. If you also implement a &lt;code&gt;__toString()&lt;/code&gt; method, that will be used instead.&lt;/p&gt;

&lt;p&gt;This is kinda shoddy though, especially needing to manually pass in information that can be inferred through the request. Another method is to pass in that extra data as part of the context of a log message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;Log::info(&#39;User logged in&#39;, [&#39;request&#39; =&amp;gt; $request, &#39;user&#39; =&amp;gt; $user]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this extra data is usually ignored. CakePHP’s internal logging doesn’t have the concept of a formatter - that’s something we’d prefer you use a full logging package like &lt;a href=&quot;https://github.com/Seldaek/monolog&quot;&gt;Monolog&lt;/a&gt; for - but you &lt;em&gt;can&lt;/em&gt; easily implement your own &lt;code&gt;LogEngine&lt;/code&gt; that does what you need. Here is a simple one that simply logs to a file with our extra data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
namespace App\Log\Engine;
use Cake\Log\Engine\FileEngine;
class ContextFileEngine
{
  public function _format($data, $context)
  {
    if (is_string($data)) {
      return $this-&amp;gt;_injectContext($data, $context)
    }

    $object = is_object($data);

    if ($object &amp;amp;&amp;amp; method_exists($data, &#39;__toString&#39;)) {
      $data = (string)$data;
      return $this-&amp;gt;_injectContext($data, $context)
    }

    if ($object &amp;amp;&amp;amp; $data instanceof JsonSerializable) {
      $data = json_decode(json_encode($data), true);
      return $this-&amp;gt;_injectContext($data, $context)
    }

    return $this-&amp;gt;_injectContext(print_r($data, true), $context);
  }

  protected function _injectContext($message, $context)
  {
    $via = null;
    $userId = null;
    if (!empty($context[&#39;request&#39;])) {
      $via = $context[&#39;request&#39;]-&amp;gt;header(&#39;X-Client&#39;);
    }
    if (!empty($context[&#39;user&#39;])) {
      $userId = $context[&#39;user&#39;]-&amp;gt;get(&#39;id&#39;);
    }

    $data = compact(&#39;message&#39;, &#39;via&#39;, &#39;userId&#39;);
    // handle arrays
    if (is_array($message)) {
      $data = $message + compact(&#39;via&#39;, &#39;userId&#39;);
    }

    return parent::_format(json_encode($data), $context);
  }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above will have output similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-12-14 7:55:00 INFO: {&quot;message&quot;: &quot;User logged in&quot;, &quot;userId&quot;: 7, &quot;via&quot;: &quot;android&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method of injecting contextual data into your logs is quite useful for later debugging, and doesn’t require too much extra work around how logs are actually written. Of course, if you need more powerful logging features, I wholeheartedly recommend looking into &lt;a href=&quot;https://github.com/Seldaek/monolog&quot;&gt;Monolog&lt;/a&gt;&lt;br /&gt;
.&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/14/custom-logging-engines-and-adding-contextual-data/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/14/custom-logging-engines-and-adding-contextual-data/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>logging</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>The Collection Class and You</title>
        <description>&lt;p&gt;Many modern applications work on a set of results, iterating over them, manipulating them, and modifying them to display the output necessary to get a job done. In CakePHP 3, we introduced the helpful &lt;code&gt;Collection&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;Here we have an array of cats info:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$cats = [
  [
    &#39;name&#39; =&amp;gt; &#39;camila&#39;,
    &#39;gender&#39; =&amp;gt; &#39;female&#39;,
    &#39;type&#39; =&amp;gt; &#39;calico&#39;,
    &#39;size&#39; =&amp;gt; &#39;small&#39;,
  ],
  [
    &#39;name&#39; =&amp;gt; &#39;railroad&#39;,
    &#39;gender&#39; =&amp;gt; &#39;male&#39;,
    &#39;color&#39; =&amp;gt; &#39;gray&#39;,
    &#39;size&#39; =&amp;gt; &#39;massive&#39;,
  ],
  [
    &#39;name&#39; =&amp;gt; &#39;santo&#39;,
    &#39;gender&#39; =&amp;gt; &#39;male&#39;,
    &#39;color&#39; =&amp;gt; &#39;black&#39;,
    &#39;size&#39; =&amp;gt; &#39;massive&#39;,
  ],
  [
    &#39;name&#39; =&amp;gt; &#39;jax&#39;,
    &#39;gender&#39; =&amp;gt; &#39;male&#39;,
    &#39;color&#39; =&amp;gt; &#39;black&#39;,
    &#39;size&#39; =&amp;gt; &#39;small&#39;,
  ],
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets filter out all the ~~best~~ female cats:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filter the data
$femaleCats = [];
foreach ($cats as $cat) {
  if ($cat[&#39;gender&#39;] == &#39;female&#39;) {
    $femaleCats[] = $cat;
  }
}
// $femaleCats should now contain camila, the cat on your right.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see what this looks like with the Collection class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// instantiate a new collection
$collection = new \Cake\Collection\Collection($cats);

// or use the helper function if you *really* want to
$collection = collection($cats);

// and now filter the data
$femaleCats = $collection-&amp;gt;filter(function ($cat) {
    return $cat[&#39;gender&#39;] == &#39;female;
});

// $femaleCats is a Collection instance that contains one cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats quite a bit simpler, though sometimes you want an array of data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$femaleCats-&amp;gt;toArray();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also chain collection methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$collection
  // get all the small cats
  -&amp;gt;filter(function ($cat) { return $info[&#39;size&#39;] == &#39;small&#39;; })
  // if they are black
  -&amp;gt;filter(function ($cat) { return $info[&#39;color&#39;] == &#39;black&#39;; })
  // if they are female
  -&amp;gt;filter(function ($cat) { return $info[&#39;gender&#39;] == &#39;female&#39;; })
  // and sort alphabetically by name descending
  -&amp;gt;sortBy(&#39;name&#39;, SORT_DESC);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty neat. Collections can work on any &lt;code&gt;array&lt;/code&gt; or instance that implements the &lt;code&gt;Traversable&lt;/code&gt; interface. In CakePHP, you can use any Collection method on the &lt;code&gt;ResultSet&lt;/code&gt; object returned by a query, which is pretty powerful for making complex find methods.&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/13/collections-class-and-you/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/13/collections-class-and-you/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>collections</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Using DSNs to simplify connection strings</title>
        <description>&lt;p&gt;In CakePHP 3, we consolidated most configuration into a single &lt;code&gt;config/app.php&lt;/code&gt;. This superscedes the old method of changing your &lt;code&gt;config/core.php&lt;/code&gt; and &lt;code&gt;config/database.php&lt;/code&gt; - as well as any other random configuration values you might set. This is good for a lot of reasons - who wants to deal with a &lt;code&gt;DATABASE_CONFIG&lt;/code&gt;? - but also means we can simplify how we configure things.&lt;/p&gt;

&lt;p&gt;One thing that always irked me was the inability to specify connection information in a single way. For instance, you might specify the host for a datastore with the following keys:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;host&lt;/code&gt;: For databases&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;server&lt;/code&gt;: For a redis caching server&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;servers&lt;/code&gt;: For memcached servers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One of quite a few different ways configuring CakePHP was yuck. A nice improvement in CakePHP 3 is the ability to specify connection information via a Data source name (DSN).&lt;/p&gt;

&lt;p&gt;A DSN is a standard used by many programming communities to encode all the information about a particular configuration. For instance, here is how I might tell you to connect to my local &lt;code&gt;test&lt;/code&gt; database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$dsn = &quot;mysql://root:cakeisali3@localhost:3306/test&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above encodes the following information:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;scheme&lt;/code&gt;: &lt;code&gt;mysql&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;user&lt;/code&gt;: &lt;code&gt;root&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;password&lt;/code&gt;: &lt;code&gt;cakeisali3&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;host&lt;/code&gt;: &lt;code&gt;localhost&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;port&lt;/code&gt;: &lt;code&gt;3306&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;database&lt;/code&gt;: &lt;code&gt;test&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also specify optional arguments via querystring:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$dsn = &quot;mysql://root:cakeisali3@localhost:3306/test?encoding=utf8&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In 3.x, the following can now use a special &lt;code&gt;url&lt;/code&gt; key. This key will be parsed and it’s values will be used to connect to a database. The following classes can be configured via dsn:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Database connections&lt;/li&gt;
  &lt;li&gt;Cache connections&lt;/li&gt;
  &lt;li&gt;Log information&lt;/li&gt;
  &lt;li&gt;Email configuration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also take advantage of this magic parsing by including the &lt;code&gt;\Cake\Core\StaticConfigTrait&lt;/code&gt; trait in your own classes.&lt;/p&gt;

&lt;p&gt;One thing that might be useful would be to extend the default schemes. In CakePHP, we map the &lt;code&gt;scheme&lt;/code&gt; to a particlar namespaced-class in the CakePHP core. You might add a &lt;code&gt;Mongo&lt;/code&gt;-based ORM Driver, but if it isn’t mapped, your app will go boom. You can map one easily though!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;ConnectionManager::dsnClassMap([&#39;console&#39; =&amp;gt; &#39;App\Database\Driver\Mongo&#39;])
// also works on the following classes:
// - Cache::dsnClassMap()
// - Email::dsnClassMap()
// - Log::dsnClassMap()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s a nifty trick I think, and one that should prove useful to anyone using cloud-providers such as &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt; or &lt;a href=&quot;http://dokku.viewdocs.io/dokku/&quot;&gt;Dokku&lt;/a&gt; for application deployment.&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/12/using-dns-to-simplify-connection-strings/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/12/using-dns-to-simplify-connection-strings/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>dsn</category>
        
        <category>config</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>SoftDeleting Entities in CakePHP 3</title>
        <description>&lt;p&gt;When creating CMS-like software, it is useful to have “undo” triggers in your application. Sometimes you want to revert to a previous version of a record, or undo a hasty delete. For the latter case, it is often useful to implement some form of a “softdelete” functionality.&lt;/p&gt;

&lt;h2 id=&quot;muffintrash&quot;&gt;Muffin/Trash&lt;/h2&gt;

&lt;p&gt;Here is a lovely plugin for 3.x that you can use to implement soft-delete. Let’s install it!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# install using composer
composer require muffin/trash:1.0.0

# require it using the plugin:load shell I just found out about
bin/cake plugin load Muffin/Trash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This plugin depends upon us having a &lt;code&gt;deleted&lt;/code&gt; or &lt;code&gt;trashed&lt;/code&gt; field in our database table. Lets create a migration for our &lt;code&gt;posts&lt;/code&gt; table:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# generate the migration using the migrations plugin
bin/cake bake migration add_deleted_to_posts deleted:datetime

# migrate the table
bin/cake migrations migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can add the behavior to our Table class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;addBehavior(&#39;Muffin/Trash.Trash&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could have also used a custom field like &lt;code&gt;deleted_at&lt;/code&gt;, but that requires more configuration, and I’m lazy so that’s not going to happen.&lt;/p&gt;

&lt;p&gt;Next, lets see how we can use this behavior:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$table = $this-&amp;gt;loadModel(&#39;Posts&#39;);
$post = $table-&amp;gt;get(1);

// simply marks the entity as in the trash
$table-&amp;gt;trash($post);

// this fails because it&#39;s already in the trash
$table-&amp;gt;trash($post);

// When the behavior is attached, `delete()` is the same as `trash()`
$table-&amp;gt;delete($post);

// &quot;recycle&#39;s&quot; things from the trash
$table-&amp;gt;restoreTrash($post);

// by default, all your trash is excluded
$posts = $table-&amp;gt;find()-&amp;gt;all();

// but you can find everything, including things in the trash
$posts = $table-&amp;gt;find()-&amp;gt;withTrashed()-&amp;gt;all();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to disable the overriding of &lt;code&gt;delete()&lt;/code&gt; with &lt;code&gt;trash()&lt;/code&gt;, you can attach the behavior like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Useful if you bake actions for soft-delete and force-delete
$this-&amp;gt;addBehavior(&#39;Muffin/Trash.Trash&#39;, [
    &#39;events&#39; =&amp;gt; [&#39;Model.beforeFind&#39;]
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The plugin is already quite useful - in fact, I’m using it in 2 applications already - and can probably take care of 90% of your soft-deletion needs.&lt;/p&gt;

</description>
        <pubDate>Fri, 11 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/11/softdeletion-in-cakephp-3/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/11/softdeletion-in-cakephp-3/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>table</category>
        
        <category>softdelete</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Faster Database Creation with the Migrations Plugin</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;I posted about this last year, but since it has landed in the official plugin, I figured I may as well cover it again :)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For developers coming from other RAD frameworks such as Ruby on Rails, you may be familiar with the ability to create table migrations. In the past, there were multiple migration plugins for CakePHP, and as of the 3.0 release, we finally have an official &lt;a href=&quot;https://github.com/cakephp/migrations&quot;&gt;cakephp/migrations&lt;/a&gt; plugin. Huge shoutout to &lt;a href=&quot;http://www.havokinspiration.fr/en/&quot;&gt;Yves Piquel&lt;/a&gt; (&lt;a href=&quot;https://github.com/HavokInspiration&quot;&gt;@HavokInspiration&lt;/a&gt;) for pushing the plugin forward.&lt;/p&gt;

&lt;p&gt;Here is a simple migration class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
use Phinx\Migration\AbstractMigration;

class CreatePosts extends AbstractMigration
{
    public function change()
    {
        $table = $this-&amp;gt;table(&#39;posts&#39;);
        $table-&amp;gt;addColumn(&#39;name&#39;, &#39;string&#39;, [
            &#39;null&#39; =&amp;gt; false,
            &#39;default&#39; =&amp;gt; null,
            &#39;limit&#39; =&amp;gt; 255,
        ]);
        $table-&amp;gt;addColumn(&#39;created&#39;, &#39;datetime&#39;, [
            &#39;null&#39; =&amp;gt; false,
            &#39;default&#39; =&amp;gt; null,
        ]);
        $table-&amp;gt;addColumn(&#39;modified&#39;, &#39;datetime&#39;, [
            &#39;null&#39; =&amp;gt; false,
            &#39;default&#39; =&amp;gt; null,
        ]);
        $table-&amp;gt;addIndex([&#39;name&#39;], [
            &#39;unique&#39; =&amp;gt; false,
            &#39;name&#39; =&amp;gt; &#39;BY_NAME&#39;,
        ]);
        $table-&amp;gt;create();
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Raise your hand if you would have wanted to create that from scratch.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.amazonaws.com/f.cl.ly/items/0I0Z2K1F3K16121h0l0e/Image%202015-12-10%20at%209.08.00%20PM.jpg&quot; alt=&quot;http://cl.ly/3W3O0P0N0M0n&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I thought as much.&lt;/p&gt;

&lt;p&gt;With the new plugin, we now have the ability to generate those from the command-line. Here is a short example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/cake bake migration create_posts name:string created modified
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;id&lt;/code&gt; fields are autocreated. This is a feature of the &lt;a href=&quot;https://phinx.org/&quot;&gt;Phinx&lt;/a&gt; project we lean on for developing PHP migrations. One-clap to &lt;a href=&quot;http://robmorgan.id.au/&quot;&gt;Rob Morgan&lt;/a&gt; for managing this project on behalf of the PHP community at large.&lt;/li&gt;
  &lt;li&gt;Certain fields have automatic types set if left null. You can always override them though.&lt;/li&gt;
  &lt;li&gt;The classname is the UpperCamelCase inflection of the first argument, and means something different depending upon the name:
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;create_table&lt;/em&gt; &lt;code&gt;/^(Create)(.*)/&lt;/code&gt;: Creates the specified table&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;drop_table&lt;/em&gt; &lt;code&gt;/^(Drop)(.*)/&lt;/code&gt;: Drops the specified table. Ignores specified field arguments.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;add_field&lt;/em&gt; &lt;code&gt;/^(Add).*(?:To)(.*)/&lt;/code&gt;: Adds fields to the specified table&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;remove_field&lt;/em&gt; &lt;code&gt;/^(Remove).*(?:From)(.*)/&lt;/code&gt;: Removes fields from the specified table&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;alter_table&lt;/em&gt; &lt;code&gt;/^(Alter)(.*)/&lt;/code&gt;: Alters the specified table. The alter_table command can be used as an alias for CreateTable and AddField.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This plugin is an absolute must-use for anything prototyping an application which schema changes. No one wants to write the SQL for them, and that goes double for writing actual schema migration files. I recommend &lt;a href=&quot;https://github.com/cakephp/migrations#generating-migrations-from-the-cli&quot;&gt;reading the docs&lt;/a&gt; on this excellent feature to learn more.&lt;/p&gt;

&lt;h2 id=&quot;bonus-round&quot;&gt;BONUS ROUND&lt;/h2&gt;

&lt;p&gt;I normally deploy my code on platforms such as &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt; or &lt;a href=&quot;http://dokku.viewdocs.io/dokku/&quot;&gt;Dokku&lt;/a&gt; where composer commands are automatically run for me. Here is my &lt;code&gt;scripts&lt;/code&gt; field in my &lt;code&gt;composer.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;scripts&quot;: {
    &quot;compile&quot;: [
        &quot;bin/cake migrations migrate&quot;,
        &quot;bin/cake migrations migrate --plugin Blog&quot;
    ],
    &quot;post-install-cmd&quot;: &quot;App\\Console\\Installer::postInstall&quot;,
    &quot;post-autoload-dump&quot;: &quot;Cake\\Composer\\Installer\\PluginInstaller::postAutoloadDump&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other than the normal stuff in there for application installation, you’ll notice I have a &lt;code&gt;scripts.compile&lt;/code&gt; key which maps to a list of migration commands to run. I run the migrations for my core application as well as the blog plugin I use in this particular application. Migrations are now fully automatic for this application, and I don’t need to worry about going in and manually altering anything!&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/10/faster-database-creation-with-migrations/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/10/faster-database-creation-with-migrations/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>table</category>
        
        <category>migrations</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Customizing your Application Template</title>
        <description>&lt;p&gt;CakePHP has long had the ability to generate new projects via the &lt;code&gt;bake&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;// my custom cat project
cake bake project camila
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the above command, CakePHP would scaffold out all the necessary directories and files for a new project (&lt;code&gt;AppModel&lt;/code&gt;, &lt;code&gt;AppController&lt;/code&gt;, configuration files, etc.). You could even customize this using a &lt;a href=&quot;http://book.cakephp.org/2.0/en/console-and-shells/code-generation-with-bake.html#for-baking-custom-projects&quot;&gt;bake skeleton&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;// be sure to copy in my cat project instead
cake bake project camila --skel Console/Templates/cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In CakePHP 3, this feature of bake has mostly gone away in favor of using &lt;code&gt;composer&lt;/code&gt; to handle scaffolding. When starting a new project, you typically do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer create-project --prefer-dist cakephp/app camila
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Composer’s &lt;code&gt;create-project&lt;/code&gt; command is great for scaffolding out new projects and is used for a variety of things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Framework-specific application repos&lt;/li&gt;
  &lt;li&gt;Framework-specific plugin modules&lt;/li&gt;
  &lt;li&gt;Generic composer packages&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The great thing about this command is that the “skeletons” are in all actually composer packages. This means it is extremely easy to use your normal distribution methods to release new versions of the package, something the CakePHP project has done with it’s &lt;a href=&quot;https://github.com/cakephp/app&quot;&gt;cakephp/app&lt;/a&gt; repository.&lt;/p&gt;

&lt;p&gt;Now, as a side-effect of this, you can &lt;em&gt;*also*&lt;/em&gt; fork any existing composer skeleton and add your own customizations. For instance, lets say we wanted to have a composer skeleton with the following plugins installed automatically:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/josegonzalez/cakephp-upload&quot;&gt;josegonzalez/upload&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/friendsofcake/crud&quot;&gt;friendsofcake/crud&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/friendsofcake/crud-view&quot;&gt;friendsofcake/crud-view&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/thephpleague/fractal&quot;&gt;league/fractal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/usemuffin/trash&quot;&gt;usemuffin/trash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can simply do the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Fork the &lt;a href=&quot;https://github.com/cakephp/app&quot;&gt;cakephp/app&lt;/a&gt; repository on github.&lt;/li&gt;
  &lt;li&gt;Change the name in the fork’s composer.json to &lt;code&gt;myname/app&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Add any custom requirements to the &lt;code&gt;composer.json&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Make a new tag/release on github.&lt;/li&gt;
  &lt;li&gt;Add it to &lt;a href=&quot;https://packagist.org&quot;&gt;packagist.org&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pretty simple. We can now use this project as a baseline for all of our new CakePHP projects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer create-project --prefer-dist myname/app camila
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from adding custom plugins, one thing you may want to look is customizing the initial project files. For instance, if you find yourself constantly adding certain helper classes, or modifying how configuration is loaded, this is a good chance to improve the base state of your initial applications.&lt;/p&gt;

&lt;p&gt;As every project is slightly different, please try and keep application-specific enhancements to a minimum, as they may only serve as a hindrance when using your skeleton. No one wants to setup an app and then spend an hour deleting useless code :)&lt;/p&gt;

&lt;p&gt;For those of you who are interested in such a project, &lt;a href=&quot;https://github.com/loadsys/CakePHP-Skeleton&quot;&gt;here is an advanced skeleton&lt;/a&gt; from the good folks at &lt;a href=&quot;https://www.loadsys.com/&quot;&gt;Loadsys Web Strategies&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/09/customizing-your-app-template/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/09/customizing-your-app-template/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>composer</category>
        
        <category>create-project</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Debugging Data in CakePHP 3</title>
        <description>&lt;p&gt;Since upgrading to CakePHP 3, you may have noticed a few changes. Yes, it’s faster, better for your cholesterol, and likely good for your Vitamin D intake&lt;sup&gt;&lt;a href=&quot;If you work less because you are working smarter, you are more likely to go outside and get some Sun. Remember to do that every so often!&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. However, what I’m referring to is the nicer debugging output.&lt;/p&gt;

&lt;p&gt;Typically when you debug an object in PHP, you use something like &lt;code&gt;print_r()&lt;/code&gt; or &lt;code&gt;var_dump()&lt;/code&gt;. With scalar types - &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; - you’ll get a pretty simple representation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;php &amp;gt; $i = 1;
php &amp;gt; var_dump($i);
int(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats really all you need. But if you try doing the same thing with an object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;class Person
{
  public $name = &#39;Alex Super Tramp&#39;;
  public $age = 100;
  private $property = &#39;property&#39;;
}

// debugging
php &amp;gt; $p = new Person;
php &amp;gt; var_dump($p);
class Person#1 (3) {
  public $name =&amp;gt;
  string(16) &quot;Alex Super Tramp&quot;
  public $age =&amp;gt;
  int(100)
  private $property =&amp;gt;
  string(8) &quot;property&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You get pretty verbose output on that object. For simple objects, this might not be so bad, but the problem is compounded when you are trying to debug a &lt;code&gt;Table&lt;/code&gt; class, or a &lt;code&gt;Controller&lt;/code&gt; etc. Fortunately, in CakePHP 3 we take advantage of a special magic method, &lt;code&gt;__debugInfo()&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;magic-methods-to-the-rescue&quot;&gt;Magic Methods to the rescue&lt;/h2&gt;

&lt;p&gt;Since PHP 5.6, you can add the method &lt;code&gt;__debugInfo()&lt;/code&gt; to any class. When instances of said class are passed through &lt;code&gt;var_dump()&lt;/code&gt;, PHP will automatically use the &lt;code&gt;array&lt;/code&gt; returned by this method to display debug info about that instance.&lt;/p&gt;

&lt;p&gt;If the method is omitted, PHP will fallback to outputting &lt;em&gt;all&lt;/em&gt; properties in that instance. Here is a lovely example of this in action.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;class Person
{
  public $name = &#39;Alex Super Tramp&#39;;
  public $age = 100;
  private $property = &#39;property&#39;;
  public function __debugInfo()
  {
    return [&#39;name&#39; =&amp;gt; $this-&amp;gt;name];
  }
}

// debugging
php &amp;gt; $p = new Person;
php &amp;gt; var_dump($p);
object Person#1 (1) {
  [&quot;name&quot;] =&amp;gt;
  string(16) &quot;Alex Super Tramp&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fancy, right? Remember, while CakePHP &lt;em&gt;does&lt;/em&gt; support this feature automatically in 5.6, users of older PHP versions will fallback to the old, yucky data dump.&lt;/p&gt;

&lt;h2 id=&quot;how-this-affects-you&quot;&gt;How this affects you&lt;/h2&gt;

&lt;p&gt;There are a few places where &lt;code&gt;__debugInfo()&lt;/code&gt; has been useful:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Form&lt;/code&gt; instances output metadata about the schema, errors, and validation rules.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ResultSet&lt;/code&gt; instances output the query that is executed.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Cell&lt;/code&gt; objects will output the environment in which they were created (view layer as well as the current request/response objects).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Entities&lt;/code&gt; will output a plethora of data regarding the current state of the entity. Useful for seeing if the entity is new or has been changed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You’re also quite welcome to add your own &lt;code&gt;__debugInfo()&lt;/code&gt; methods to custom classes. For those of you who are curious, I definitely recommend looking at the list of &lt;a href=&quot;https://secure.php.net/manual/en/language.oop5.magic.php&quot;&gt;PHP Magic Methods&lt;/a&gt;, which might just be handy&lt;sup&gt;&lt;a href=&quot;My current favorite magic method is the `__invoke()` method :)&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; in a pinch!&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Tue, 08 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/08/debugging-data-in-cakephp-3/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/08/debugging-data-in-cakephp-3/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>magic-methods</category>
        
        
        <category>cakephp</category>
        
      </item>
    
  </channel>
</rss>
