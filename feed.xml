<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jose Diaz-Gonzalez</title>
    <description>Developer, Accidental Ops Guy, and CakePHP Core Developer</description>
    <link>http://josediazgonzalez.com/</link>
    <atom:link href="http://josediazgonzalez.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 22 Dec 2015 09:33:52 +0000</pubDate>
    <lastBuildDate>Tue, 22 Dec 2015 09:33:52 +0000</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Tracking Logged in User Actions</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Note: for the purposes of this post, I chose an easy to understand plugin, but I recommend using the &lt;a href=&quot;https://github.com/usemuffin/footprint&quot;&gt;footprint&lt;/a&gt; plugin as it supports many more features than the one I cover here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a pretty straightforward post. In CakePHP 3, we’ve removed a lot of the ability to access the session except where there is a &lt;code&gt;Request&lt;/code&gt; object. Static access to &lt;code&gt;CakeSession&lt;/code&gt; is gone, and it’s not coming back, so please stop asking for it. And stop using &lt;code&gt;$_SESSION&lt;/code&gt;, that breaks the cake.&lt;/p&gt;

&lt;p&gt;One thing this affects is the ability to see user session data in the Model layer. Typically you want to track &lt;em&gt;who&lt;/em&gt; performed an action &lt;em&gt;when&lt;/em&gt; the action happens. It’s quite nice to hide this in your model layer, as opposed to mangling data when it’s going into an entity.&lt;/p&gt;

&lt;p&gt;How do we do this? We can use the &lt;a href=&quot;https://github.com/ceeram/blame&quot;&gt;&lt;code&gt;ceeram/blame&lt;/code&gt; plugin&lt;/a&gt;!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# ugh more things to install
composer require ceeram/cakephp-blame

# load it
bin/cake plugin load Ceeram/Blame
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we add the following &lt;code&gt;use&lt;/code&gt; call to the inside of our &lt;code&gt;src/Controller/AppController.php&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;class AppController extends Controller
{
  use \Ceeram\Blame\Controller\BlameTrait;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally add the behavior to our table:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function initialize(array $config)
{
    $this-&amp;gt;addBehavior(&#39;Ceeram/Blame.Blame&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now whenever a new record is saved, the &lt;code&gt;created_by&lt;/code&gt; field is set to the logged in user’s &lt;code&gt;id&lt;/code&gt;. When records are modified, the &lt;code&gt;modified_by&lt;/code&gt; field will be set.&lt;/p&gt;

&lt;h2 id=&quot;how-does-it-work&quot;&gt;How does it work?&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;BlameTrait&lt;/code&gt; we added to our &lt;code&gt;AppController&lt;/code&gt; actually does all the heavy lifting. It adds a &lt;a href=&quot;https://github.com/ceeram/blame/blob/master/src/Event/LoggedInUserListener.php&quot;&gt;listener&lt;/a&gt; that will add the appropriate data to our Table instances whenever they are saved through the magic of &lt;a href=&quot;https://github.com/ceeram/blame/blob/master/src/Controller/BlameTrait.php#L18&quot;&gt;&lt;code&gt;Controller::loadModel()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It’s actually quite clever, and I’m a bit upset I hadn’t previously thought of it. The same trick probably works in 2.x.&lt;/p&gt;

&lt;p&gt;For users that find this plugin limiting in some way, I definitely recommend reading the code over, extending it, or applying the clever usage of the event system to your own application.&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/21/tracking-logged-in-user-actions/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/21/tracking-logged-in-user-actions/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>auth</category>
        
        <category>user-tracking</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Creating Custom Background Shells</title>
        <description>&lt;p&gt;In a previous post, I mentioned how awesome it would be to have a background queueing system to perform long-running tasks. While there are many queueing systems, today I will re-introduce Queuesadilla, with an aim to explain how CakePHP shells work.&lt;/p&gt;

&lt;h2 id=&quot;shell-skeleton&quot;&gt;Shell Skeleton&lt;/h2&gt;

&lt;p&gt;Before we being, lets start with understanding what we need:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Queuesadilla is a long-running task. It handles it’s own state, so if it crashes, all we really care about is ensuring whatever process manager we are using will restart it. Given that, we don’t need much error handling.&lt;/li&gt;
  &lt;li&gt;We should be able to configure most of the options in Queuesadilla. We might not use them today, but they will come in handy later.&lt;/li&gt;
  &lt;li&gt;Logging should be done using the CakePHP logger.&lt;/li&gt;
  &lt;li&gt;Default configuration should come from the &lt;code&gt;Configure&lt;/code&gt; class, same as everything else.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that we know what we are building, let’s bake the shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# install Queuesadilla
composer require josegonzalez/queuesadilla:dev-master

# bake the shell
bin/cake bake shell Queuesadilla
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should now have a &lt;code&gt;src/Shell/QueueShell.php&lt;/code&gt; with contents similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Shell;

use Cake\Console\Shell;

class QueueShell extends Shell
{
    public function main()
    {
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can invoke the shell with &lt;code&gt;bin/cake queue&lt;/code&gt;, and you will see the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ bin/cake queue

Welcome to CakePHP v5.0.1 Console
---------------------------------------------------------------
App : src
Path: /Users/jose/src/playground/src/
PHP : 7.0.1
---------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Yes, that’s CakePHP 5, and yes, it supports MRD (Mind Reading Development)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;adding-a-layer&quot;&gt;Adding a layer&lt;/h2&gt;

&lt;p&gt;This isn’t very helpful. Lets fill in that &lt;code&gt;main()&lt;/code&gt; method with some logic:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function main()
{
    $EngineClass = &quot;josegonzalez\\Queuesadilla\\Engine\\MysqlEngine&#39;;
    $WorkerClass = &quot;josegonzalez\\Queuesadilla\\Worker\\SequentialWorker&quot;;

    $logger = \Cake\Log\Log::engine(&#39;default&#39;);
    $engine = new $EngineClass($logger, [
      &#39;url&#39; =&amp;gt; &#39;mysql://user:password@localhost:3306/database_name&#39;
    ]);

    $worker = new $WorkerClass($engine, $logger);
    $worker-&amp;gt;work();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming you have that database configured, this will work and output something similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-12-22 00:54:39 Info: Starting worker
2015-12-22 00:54:39 Debug: No job!
2015-12-22 00:54:40 Debug: No job!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we queued a job, you could see the job output as well. We don’t care too much about that now, as we still need to ensure this thing can be configured for more than just our test app.&lt;/p&gt;

&lt;h2 id=&quot;option-parsing&quot;&gt;Option Parsing&lt;/h2&gt;

&lt;p&gt;Every cakephp shell has a method called &lt;code&gt;getOptionParser()&lt;/code&gt;. This returns an &lt;code&gt;ArgumentParser&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Just kidding, it returns an &lt;code&gt;OptionParser&lt;/code&gt;. You can add as many options as you’d like to this, and these options can later be accessed within your shell by using the &lt;code&gt;$this-&amp;gt;params&lt;/code&gt; array attribute. The following is what ours will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function getOptionParser()
{
    $parser = parent::getOptionParser();
    $parser-&amp;gt;addOption(&#39;engine&#39;, [
        &#39;choices&#39; =&amp;gt; [
            &#39;Beanstalk&#39;,
            &#39;Iron&#39;,
            &#39;Memory&#39;,
            &#39;Mysql&#39;,
            &#39;Null&#39;,
            &#39;Redis&#39;,
            &#39;Synchronous&#39;,
        ],
        &#39;default&#39; =&amp;gt; &#39;Mysql&#39;,
        &#39;help&#39; =&amp;gt; &#39;Name of engine&#39;,
        &#39;short&#39; =&amp;gt; &#39;e&#39;,
    ]);
    $parser-&amp;gt;addOption(&#39;queue&#39;, [
        &#39;help&#39; =&amp;gt; &#39;Name of a queue&#39;,
        &#39;short&#39; =&amp;gt; &#39;q&#39;,
    ]);
    $parser-&amp;gt;addOption(&#39;logger&#39;, [
        &#39;help&#39; =&amp;gt; &#39;Name of a configured logger&#39;,
        &#39;default&#39; =&amp;gt; &#39;stdout&#39;,
        &#39;short&#39; =&amp;gt; &#39;l&#39;,
    ]);
    $parser-&amp;gt;addOption(&#39;worker&#39;, [
        &#39;choices&#39; =&amp;gt; [
            &#39;Sequential&#39;,
            &#39;Test&#39;,
        ],
        &#39;default&#39; =&amp;gt; &#39;Sequential&#39;,
        &#39;help&#39; =&amp;gt; &#39;Name of worker class&#39;,
        &#39;short&#39; =&amp;gt; &#39;w&#39;,
    ]);
    $parser-&amp;gt;description(__(&#39;Runs a Queuesadilla worker&#39;));
    return $parser;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&quot;http://book.cakephp.org/3.0/en/console-and-shells.html#configuring-options-and-generating-help&quot;&gt;online docs&lt;/a&gt; do a good job of explaining these and other ways of manipulating an &lt;code&gt;OptionParser&lt;/code&gt;, but the above code should be pretty self-explanatory. With the above code, we’ll have the following output for &lt;code&gt;bin/cake queue -h&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ bin/cake queue -h

Welcome to CakePHP v5.0.1 Console
---------------------------------------------------------------
App : src
Path: /Users/jose/src/playground/src/
PHP : 7.0.1
---------------------------------------------------------------
Runs a Queuesadilla worker.

Usage:
cake queuesadilla [options]

Options:

--help, -h     Display this help.
--verbose, -v  Enable verbose output.
--quiet, -q    Enable quiet output.
--engine, -e   Name of engine (default: Mysql)
               (choices:
               Beanstalk|Iron|Memory|Mysql|Null|Redis|Synchronous)
--queue, -q    Name of a queue
--logger, -l   Name of a configured logger (default:
               stdout)
--worker, -w   Name of worker class (default:
               Sequential) (choices:
               Sequential|Test)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty chawesome. Let’s modify our code to use this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function main()
{
    $engine = $this-&amp;gt;params[&#39;engine&#39;];
    $worker = $this-&amp;gt;params[&#39;worker&#39;];
    $EngineClass = &quot;josegonzalez\\Queuesadilla\\Engine\\&quot; . $engine . &#39;Engine&#39;;
    $WorkerClass = &quot;josegonzalez\\Queuesadilla\\Worker\\&quot; . $worker . &quot;Worker&quot;;

    $config = $this-&amp;gt;getEngineConfig();
    $loggerName = $this-&amp;gt;getLoggerName();

    $logger = \Cake\Log\Log::engine($loggerName);
    $engine = new $EngineClass($logger, $config);

    $worker = new $WorkerClass($engine, $logger);
    $worker-&amp;gt;work();
}

protected function getEngineConfig()
{
    $config = \Cake\Core\Configure::read(&#39;Queuesadilla.engine&#39;);
    if (empty($config)) {
        throw new Exception(&#39;Invalid Queuesadilla.engine config&#39;);
    }

    if (!empty($this-&amp;gt;params[&#39;queue&#39;])) {
        $config[&#39;queue&#39;] = $this-&amp;gt;params[&#39;queue&#39;];
    }
    return $config;
}

protected function getLoggerName()
{
    $loggerName = \Cake\Core\Configure::read(&#39;Queuesadilla.logger&#39;);
    if (empty($loggerName)) {
        $loggerName = $this-&amp;gt;params[&#39;logger&#39;];
    }
    return $loggerName;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only thing left to do is add the appropriate config to our &lt;code&gt;config/app.php&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&#39;Queuesadilla&#39; =&amp;gt; [
    &#39;engine&#39; =&amp;gt; [
        // yum environment variables
        &#39;url&#39; =&amp;gt; env(&#39;DATABASE_URL&#39;),
    ],
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run the worker now, you’ll get the same output as before, only this time it will respect any additional options you give it, as well as application-level changes to the logger or the backing engine.&lt;/p&gt;

&lt;h2 id=&quot;testing-the-job-runner&quot;&gt;Testing the job runner&lt;/h2&gt;

&lt;p&gt;Now that we have a simple worker going, lets test it with a simple job. Place the following in &lt;code&gt;src/Job/TestJob.php&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Job;

class TestJob
{
    public function perform($job)
    {
        debug($job-&amp;gt;data());
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we can test this using the &lt;code&gt;bin/cake console&lt;/code&gt; shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// nonsense boilerplate so we can get a logger in the `bin/cake console` shell
$stdout = new \Cake\Log\Engine\ConsoleLog([
    &#39;types&#39; =&amp;gt; [&#39;notice&#39;, &#39;info&#39;, &#39;debug&#39;],
    &#39;stream&#39; =&amp;gt; new \Cake\Console\ConsoleOutput(&#39;php://stdout&#39;),
]);
\Cake\Log\Log::config(&#39;stdout&#39;, [&#39;engine&#39; =&amp;gt; $stdout]);
$logger = \Cake\Log\Log::engine(&#39;stdout&#39;);

// create an engine
$engine = new \josegonzalez\Queuesadilla\Engine\MysqlEngine(
  $logger,
  [&#39;url&#39; =&amp;gt; env(&#39;DATABASE_URL&#39;)]
);

// create a queue connection
$queue = new \josegonzalez\Queuesadilla\Queue($engine);

// zhu li, queue the thing!
$queue-&amp;gt;push([&#39;\App\Job\TestJob&#39;, &#39;perform&#39;], [&#39;sleep&#39; =&amp;gt; 3, &#39;message&#39; =&amp;gt; &#39;hi&#39;, &#39;raise&#39; =&amp;gt; false]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you were running the &lt;code&gt;bin/cake queue&lt;/code&gt; shell in another terminal, you should have seen the debug output.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;CakePHP Shells are actually quite powerful. You can use them not only as wrappers of external job running tools, but also as a way to invoke administrative, one-off code as in the &lt;code&gt;bin/cake console&lt;/code&gt; shell. You could also write longer, one-off tasks as custom shells, and cron-tasks &lt;em&gt;definitely&lt;/em&gt; belong in them.&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/20/creating-custom-background-shells/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/20/creating-custom-background-shells/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>shells</category>
        
        <category>queueing</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Tracking Requests Via Dispatch Filters</title>
        <description>&lt;p&gt;CakePHP 2 added dispatch filters. These were cool, but there were a few problems:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They were managed to configure, which meant it was harder for dependencies and configuration to be added/removed to middleware as the configuration was managed away from the actual dispatch cycle.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Configure&lt;/code&gt;-based management makes it harder to reason about when a particular dispatch filter will be hit.&lt;/li&gt;
  &lt;li&gt;Because of the above, controller handling had to be outside of the middleware layer. Sometimes you want to do something special, and in our case you basically had to replace the whole Dispatcher to do that. Boo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In CakePHP 3 we now have a nice stack of middleware you configure in &lt;code&gt;config/bootstrap.php&lt;/code&gt; using the &lt;code&gt;DispatcherFactory&lt;/code&gt;. Many applications have no need to modify the stack, but they can be quite handy in a pinch. For instance, what if you wanted to track the number of times certain controller/action pairs in your application are requested?&lt;/p&gt;

&lt;h2 id=&quot;metrics-tracking-via-statsd&quot;&gt;Metrics tracking via StatsD&lt;/h2&gt;

&lt;p&gt;I’m not going to get too much into StatsD, except to say it’s a way to track metrics in a time-series database software called graphite. &lt;a href=&quot;https://codeascraft.com/2011/02/15/measure-anything-measure-everything/&quot;&gt;Here&lt;/a&gt; is a blog post by Etsy covering StatsD and why it’s awesome.&lt;/p&gt;

&lt;p&gt;In our case, we’re going to send a counter to StatsD every time a controller/action pair is hit. Let’s install a library to handle talking to statsd:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require league/statsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we’ll wire up the simplest of dispatch filters. We will be tracking requests &lt;em&gt;after&lt;/em&gt; they happen, in case anything happens during the dispatch cycle that would change what would be requested:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Routing\Filter;

use Cake\Event\Event;
use Cake\Routing\DispatcherFilter;
use Cake\Utility\Inflector;
use League\StatsD\Client;

class StatsdFilter extends DispatcherFilter
{
    // only create the client once and
    // keep a reference to it
    protected $client;

    // these can be overriden whenever
    // we add the dispatch filter
    protected $_defaultConfig = [
        &#39;host&#39; =&amp;gt; &#39;127.0.0.1&#39;,
        &#39;port&#39; =&amp;gt; 8125,
        &#39;namespace&#39; =&amp;gt; &#39;app&#39;
    ];
    public function __construct($config = [])
    {
        // ensure configuration is set
        parent::__construct($config);

        $this-&amp;gt;client = new Client();
        $this-&amp;gt;client-&amp;gt;configure([
            &#39;host&#39; =&amp;gt; $this-&amp;gt;config(&#39;host&#39;),
            &#39;port&#39; =&amp;gt; $this-&amp;gt;config(&#39;port&#39;),
            &#39;namespace&#39; =&amp;gt; $this-&amp;gt;config(&#39;namespace&#39;),
        ]);
    }

    public function afterDispatch(Event $event)
    {
        $request = $event-&amp;gt;data[&#39;request&#39;];
        $response = $event-&amp;gt;data[&#39;response&#39;];

        // Graphite uses folders for metrics
        // We dasherize the names to keep all metrics sane-looking
        $controller = Inflector::dasherize($response-&amp;gt;params[&#39;controller&#39;])
        $action = Inflector::dasherize($response-&amp;gt;params[&#39;action&#39;])
        $statusCode = $response-&amp;gt;statusCode();

        // track controller/action pairs
        $statsd-&amp;gt;increment(sprintf(&#39;web.%s.%s.hit&#39;, $controller, $action));

        // track response codes for those pairs as well
        $statsd-&amp;gt;increment(sprintf(&#39;web.%s.%s.%d&#39;, $controller, $action, $statusCode));
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And configuring it is easy. Simply add the following to your &lt;code&gt;config/bootstrap.php&lt;/code&gt; after the &lt;code&gt;DispatcherFactory:add(&#39;ControllerFactory&#39;)&lt;/code&gt; call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;DispatcherFactory::add(&#39;StatsdFilter&#39;, [
    &#39;host&#39; =&amp;gt; &#39;127.0.0.1&#39;,
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now you’ll be tracking metrics in StatsD!&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://book.cakephp.org/3.0/en/development/dispatch-filters.html&quot;&gt;docs on dispatch filters&lt;/a&gt; have another example - altering cache headers on certain requests - but it should be fairly easy to come up with useful ways of bending dispatch filters to your will!&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/19/tracking-requests-via-dispatch-filters/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/19/tracking-requests-via-dispatch-filters/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>dispatch-filters</category>
        
        <category>statsd</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Managing Application Configuration</title>
        <description>&lt;p&gt;Most applications have a few custom bits of configuration. For instance, you might configure your error handler, or add some special facebook authentication key. Generally, these fall into two categories:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;configuration specific to the application (how errors are handled)&lt;/li&gt;
  &lt;li&gt;configuration specific to the environment (which key to use for a service in staging/prod)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the former, I like creating a directory structure similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ls config/
app.php
bootstrap.php
bootstrap_cli.php
bootstrap/environment.php
bootstrap/functions.php
bootstrap/functions_cli.php
bootstrap/keys.php
bootstrap/services.php
paths.php
routes.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generally speaking, I have a &lt;code&gt;bootstrap&lt;/code&gt; folder which contains multiple php files I require from my &lt;code&gt;bootstrap.php&lt;/code&gt;. I use the &lt;code&gt;_cli&lt;/code&gt; suffix on the filename to denote cli-based configuration. I also separate the config by the type of thing I am configuring, e.g. &lt;code&gt;keys.php&lt;/code&gt; contains keys for stuff like an S3 bucket, while &lt;code&gt;services.php&lt;/code&gt; contains a list of services mapping to their &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; urls.&lt;/p&gt;

&lt;p&gt;Sometimes I don’t &lt;em&gt;want&lt;/em&gt; to store this information in the repository. For instance, I might have a specific bit of authentication information for the Facebook application my app is communicating with, or credentials to some SFTP bucket where important documents are stored. Maybe the database credentials are sacred and I don’t want everyone on the dev team to connect directly to production. Generally speaking, I have alternatives I would use in this case so that the functionality works both locally and in production, albeit with slightly different data.&lt;/p&gt;

&lt;p&gt;In this case, I use &lt;code&gt;php-dotenv&lt;/code&gt; to configure &lt;a href=&quot;http://12factor.net/config&quot;&gt;environment variables&lt;/a&gt; for use in my application. Let’s install it in our application first:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require josegonzalez/dotenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Normally I add the following bit of code &lt;em&gt;right&lt;/em&gt; after the composer &lt;code&gt;vendor/autoload.php&lt;/code&gt; is required in my &lt;code&gt;config/bootstrap.php&lt;/code&gt;. This will affect both cli and web requests, so there isn’t a need to do it twice:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;if (!env(&#39;APP_NAME&#39;)) {
    josegonzalez\Dotenv\Loader::load([
        &#39;filepaths&#39; =&amp;gt; [
            __DIR__ . DS . &#39;.env&#39;,
            __DIR__ . DS . &#39;.env.default&#39;,
        ],
        &#39;toServer&#39; =&amp;gt; false,
        &#39;skipExisting&#39; =&amp;gt; [&#39;toServer&#39;],
        &#39;raiseExceptions&#39; =&amp;gt; false
    ]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;a href=&quot;https://github.com/josegonzalez/php-dotenv&quot;&gt;php-dotenv&lt;/a&gt; project supports being called in a &lt;a href=&quot;https://github.com/josegonzalez/php-dotenv#usage&quot;&gt;non-static way&lt;/a&gt; if you hate statics.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.env&lt;/code&gt; files are simply a list of &lt;code&gt;export KEY=VALUE&lt;/code&gt; statements. If you know bash, you know how to use &lt;code&gt;.env&lt;/code&gt; files. There is a &lt;a href=&quot;https://github.com/josegonzalez/php-dotenv#usage&quot;&gt;primer&lt;/a&gt; in the readme.&lt;/li&gt;
  &lt;li&gt;You can load multiple &lt;code&gt;.env&lt;/code&gt; files. The first one that exists on disk will be used. This is useful if you have &lt;code&gt;gitignored&lt;/code&gt; one like I do but wish to provide a default &lt;code&gt;.env&lt;/code&gt; file&lt;/li&gt;
  &lt;li&gt;You can tell &lt;code&gt;php-dotenv&lt;/code&gt; to populate a number of variables. In this case, I am populating &lt;code&gt;$_SERVER&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;By default, exceptions are raised whenever there is an issue loading or parsing a &lt;code&gt;.env&lt;/code&gt; file. Rather than raise an expection at the bootstrap level, I just turn them off and assume the application has sane defaults. YMMV.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, when is this useful? Say I have a default database config, and I store this in my &lt;code&gt;config/.env.default&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# cakephp can read DSNs, remember?
export DATABASE_URL=&quot;mysql://user:password@localhost/database?encoding=utf8&amp;amp;timezone=UTC&amp;amp;cacheMetadata=true&amp;amp;quoteIdentifiers=false&amp;amp;persistent=false&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And I read it into my &lt;code&gt;config/app.php&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&#39;Datasources&#39; =&amp;gt; [
    &#39;default&#39; =&amp;gt; [
        &#39;url&#39; =&amp;gt; env(&#39;DATABASE_URL&#39;),
    ],
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In production, my &lt;code&gt;nginx.conf&lt;/code&gt; sets &lt;code&gt;APP_NAME&lt;/code&gt; and &lt;code&gt;DATABASE_URL&lt;/code&gt;, and therefore I don’t load the default mysql configuration. But what if I didn’t? I could create a &lt;code&gt;config/.env&lt;/code&gt; file on my server with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;export DATABASE_URL=&quot;mysql://app:pass@some-host/app-database?encoding=utf8&amp;amp;timezone=UTC&amp;amp;cacheMetadata=true&amp;amp;quoteIdentifiers=false&amp;amp;persistent=true&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And my application would be none the wiser. What’s even &lt;em&gt;more&lt;/em&gt; awesome is that I can &lt;em&gt;also&lt;/em&gt; use this same trick to provide custom environments locally. If I have a developer who has slightly different config than the defaults, they can simply create a &lt;code&gt;config/.env&lt;/code&gt; file with their own customizations and they are off to the races!&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/18/managing-application-configuration/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/18/managing-application-configuration/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>configuration</category>
        
        <category>environment</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>CakePHP Shells I didn&#39;t know about</title>
        <description>&lt;p&gt;Did you know there is a shell that allows you to enable a plugin after installing it via composer?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/cake plugin load Muffin/Trash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also load the plugin’s bootstrap or routes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# I&#39;m not releasing this, so don&#39;t try and composer require it
bin/cake plugin load --bootstrap --routes Josegonzalez/Blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most people installed CakePHP 3 using the &lt;a href=&quot;http://josediazgonzalez.com/2015/12/09/customizing-your-app-template/&quot;&gt;&lt;code&gt;cakephp/app&lt;/code&gt; project template&lt;/a&gt;, so you have access to both &lt;code&gt;bake&lt;/code&gt; and &lt;code&gt;migrations&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# migrate all the things!
bin/cake migrations migrate

# get a migration status
bin/cake migrations status

# bake a migration
bin/cake bake migration_snapshot Initial

# bake a form (or really anything else)
bin/cake bake form AddForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are running migrations, it may be useful to clear the ORM’s cache so that your code is aware of the new fields:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/cake migrations migrate &amp;amp;&amp;amp; bin/cake orm_cache clear
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if you are deploying code, maybe you want to ensure the cache is set &lt;em&gt;before&lt;/em&gt; the first user’s request comes in, speeding up that initial request:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/cake orm_cache build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’m a big fan of the &lt;code&gt;server&lt;/code&gt; shell. It allows me to quickly test an app locally without needing to setup a virtualhost or a webserver. Very useful for development, and something I recommend everyone learn to place in their arsenal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# specify a port I know won&#39;t collide with other stuff I run on my machine
bin/cake server -p 1995
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In older versions of CakePHP 3, we introduced a full REPL around &lt;a href=&quot;https://github.com/borisrepl/boris&quot;&gt;boris&lt;/a&gt;, but that has since been replaced with &lt;a href=&quot;http://psysh.org/&quot;&gt;Psysh&lt;/a&gt;. It’s actually quite nice, and lets me test out new code I’ve written in various scenarios.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# yo dawg, i hurd u liek shells, so I put a shell in your shell so you can shell while you shell!
bin/cake console
# Note: it saves your history, just like a regular shell, which is nice :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, something I missed from my short stint doing Ruby on Rails, being able to list routes in an application.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# list routes
bin/cake routes

# see what a url route maps to internally
bin/cake routes check /articles

# generate the url route for a key:pair setup
bin/cake routes generate controller:Articles action:view 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bonus&quot;&gt;Bonus!&lt;/h2&gt;

&lt;p&gt;A shell I discovered a few weeks back is one by the ever-helpful &lt;a href=&quot;https://www.loadsys.com/&quot;&gt;Loadsys Web Strategies&lt;/a&gt; company. It lets you read into keys were loaded into configure (which is great if you have an app with several &lt;code&gt;Configure::load()&lt;/code&gt; statements and don’t know where a key might be):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# install it
composer require loadsys/cakephp-config-read:~3.0

# load it
bin/cake plugin load ConfigRead

# use it (on your debug mode)
bin/cake config_read debug

# on your application&#39;s encoding
bin/cake config_read App.encoding

# on the default database configuration
bin/cake config_read Datasources.default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is there a CakePHP Shell you’d like to see ported from another framework? Something you find useful or lacking? Leave a note in the comments.&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/17/cakephp-shells-i-didnt-know-about/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/17/cakephp-shells-i-didnt-know-about/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>shells</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Custom Validation Rule Classes</title>
        <description>&lt;p&gt;I was asked yesterday if I could elaborate on my &lt;code&gt;OwnedByCurrentUser&lt;/code&gt; rule class. I’ll post it here, but also post on my process for developing rules.&lt;/p&gt;

&lt;h2 id=&quot;organization&quot;&gt;Organization&lt;/h2&gt;

&lt;p&gt;First off, I &lt;em&gt;hate&lt;/em&gt; having anonymous functions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They are harder to test in isolation of the enclosing scope.&lt;/li&gt;
  &lt;li&gt;They make it more difficult to reason about classes because of the implicit extra scope/binding of the callable.&lt;/li&gt;
  &lt;li&gt;I think they look silly.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I definitely think they have their place - configuring the CRUD Plugin is one - but normally I try to stay away from them if possible. Instead, I use &lt;a href=&quot;/2015/12/06/invoking-callable-classes/&quot;&gt;invokable callable classes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For rules, I normally place my callable classes in &lt;code&gt;src/Form/Rule&lt;/code&gt;. Here is what our initial &lt;code&gt;OwnedByCurrentUser&lt;/code&gt; rule looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Form\Rule;
class OwnedByCurrentUser
{
    /**
     * Performs the check
     *
     * @param mixed $value The data to validate
     * @param array $context A key value list of data that could be used as context
     * during validation. Recognized keys are:
     * - newRecord: (boolean) whether or not the data to be validated belongs to a
     *   new record
     * - data: The full data that was passed to the validation process
     * - field: The name of the field that is being processed
     * - providers: associative array with objects or class names that will
     *   be passed as the last argument for the validation method
     * @return bool
     */
    public function __invoke($value, array $context = null)
    {
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;filling-it-in&quot;&gt;Filling it in&lt;/h2&gt;

&lt;p&gt;When I write a rule, I’ll first write it to handle one very specific case. In this particular application, I had to ensure that a particular &lt;code&gt;Battle&lt;/code&gt; was owned by a participant in the battle before allowing them to perform certain actions. My invoke looked like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function __invoke($value, array $context = null)
{
    $table = \Cake\ORM\TableRegistry::get(&#39;Battles&#39;);
    return !!$table-&amp;gt;find()-&amp;gt;where([
      &#39;id&#39; =&amp;gt; (int)$value,
      &#39;user_id&#39; =&amp;gt; $userId,
    ])-&amp;gt;firstOrFail();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above sort of works:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It actually throws a &lt;code&gt;Cake\Datasource\Exception\RecordNotFoundException&lt;/code&gt; exception, which is incorrect for my use case, since I don’t want validation rules to throw exceptions&lt;/li&gt;
  &lt;li&gt;I wasn’t sure where I was passing in the &lt;code&gt;$userId&lt;/code&gt;. The &lt;code&gt;$context&lt;/code&gt; maybe?&lt;/li&gt;
  &lt;li&gt;I’m offloading a lot of logic into the database. What if I don’t have compound index on &lt;code&gt;id/user_id&lt;/code&gt;? That would slow down this part of the app (maybe not a concern).&lt;/li&gt;
  &lt;li&gt;There was a table where I was thinking of re-using this in the near future that used &lt;code&gt;creator_id&lt;/code&gt; instead of &lt;code&gt;user_id&lt;/code&gt; to denote who owned the record (legacy applications, am I right?). This was hardcoded to the one field, which would mean more copy-pasting. I also couldn’t modify the table that was being checked. Boo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once I had a few tests going that brought up the above issues, I knew I had to refactor it.&lt;/p&gt;

&lt;h2 id=&quot;fixing-issues&quot;&gt;Fixing issues&lt;/h2&gt;

&lt;p&gt;I took a step back and realized I wanted to instantiate rules and then invoke them several times. This meant modifying the rule instance state, as well as passing in an initial state. First, lets add a constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;protected $_alias;
protected $_userId;
protected $_fieldName;

/**
 * Performs the check
 *
 * @param string $alias Table alias
 * @param mixed $userId A string or integer denoting a user&#39;s id
 * @param string $fieldName A name to use when checking an entity&#39;s association
 * @return void
 */
public function __construct($alias, $userId, $fieldName = &#39;user_id&#39;)
{
    $this-&amp;gt;_alias = $alias;
    $this-&amp;gt;_userId = $userId;
    $this-&amp;gt;_fieldName = $fieldName;
}

public function setTable($alias)
{
    $this-&amp;gt;_alias = $alias;
}

public function setUserId($userId)
{
    $this-&amp;gt;_userId = $userId;
}

public function setFieldName($fieldName)
{
    $this-&amp;gt;_fieldName = $fieldName;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each field is a protected field - meaning I can extend this easily by subclassing - and all have setters - meaning I can reuse a rule instance if necessary. Next I needed to modify the &lt;code&gt;__invoke()&lt;/code&gt; method to use my customizations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function __invoke($value, array $context = null)
{
    // handle the case where no userId was
    // specified or the user is logged out
    $userId = $this-&amp;gt;_userId;
    if (empty($userId)) {
        return false;
    }

    // use the Table class specified by our configured alias
    $table = \Cake\ORM\TableRegistry::get($this-&amp;gt;_alias);

    // Don&#39;t make the database do the heavy-lifting
    $entity = $table-&amp;gt;find()-&amp;gt;where([&#39;id&#39; =&amp;gt; (int)$value])-&amp;gt;first();
    if (empty($entity)) {
        return false;
    }

    // Ensure any customized field matches our userId
    return $entity-&amp;gt;get($this-&amp;gt;_fieldName) == $userId;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;wrapping-it-up&quot;&gt;Wrapping it up&lt;/h3&gt;

&lt;p&gt;From yesterday’s post, here is how the rule is invoked:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;protected function _buildValidator(Validator $validator)
{
    // use $this-&amp;gt;_user in my validation rules
    $userId = $this-&amp;gt;_user-&amp;gt;get(&#39;id&#39;);
    $validator-&amp;gt;add(&#39;id&#39;, &#39;custom&#39;, [
        &#39;rule&#39; =&amp;gt; function ($value, $context) use ($userId) {
            // reusing an invokable class
            $rule = new OwnedByCurrentUser(&#39;Battles&#39;, $userId);
            return $rule($value, $context);
        },
        &#39;message&#39; =&amp;gt; &#39;This photo isn\&#39;t yours to battle with&#39;
    ]);

    // This should also work
    $validator-&amp;gt;add(&#39;id&#39;, &#39;custom&#39;, [
        &#39;rule&#39; =&amp;gt; new OwnedByCurrentUser(&#39;Battles&#39;, $userId),
        &#39;message&#39; =&amp;gt; &#39;This photo isn\&#39;t yours to battle with&#39;
    ]);

    // As should this (and you can now re-use the rule)
    $rule = new OwnedByCurrentUser(&#39;Battles&#39;, $userId);
    $validator-&amp;gt;add(&#39;id&#39;, &#39;custom&#39;, [
        &#39;rule&#39; =&amp;gt; $rule,
        &#39;message&#39; =&amp;gt; &#39;This photo isn\&#39;t yours to battle with&#39;
    ]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mopping-up&quot;&gt;Mopping up&lt;/h2&gt;

&lt;p&gt;When I first found out I could do this, I was quite delighted by it. Validation rules have always been a pain to test, and this was as good as it got. I now have an easy to understand class that is both easily testable and gives me increased code reuse.&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/16/custom-validation-rule-classes/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/16/custom-validation-rule-classes/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>rules</category>
        
        <category>validation</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Stuffing Complex Logic into Model-less Forms</title>
        <description>&lt;p&gt;One new feature of CakePHP 3 is the ability to have &lt;a href=&quot;http://book.cakephp.org/3.0/en/core-libraries/form.html&quot;&gt;Model-less form classes&lt;/a&gt;. These are typically useful for stuff like contact forms that might send an email:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Form;

use Cake\Form\Form;
use Cake\Form\Schema;
use Cake\Mailer\Email;
use Cake\Validation\Validator;

class ContactForm extends Form
{
    // require some data
    protected function _buildSchema(Schema $schema)
    {
        return $schema-&amp;gt;addField(&#39;name&#39;, &#39;string&#39;)
            -&amp;gt;addField(&#39;email&#39;, [&#39;type&#39; =&amp;gt; &#39;string&#39;])
            -&amp;gt;addField(&#39;body&#39;, [&#39;type&#39; =&amp;gt; &#39;text&#39;]);
    }

    // validate the incoming data
    protected function _buildValidator(Validator $validator)
    {
        return $validator-&amp;gt;add(&#39;name&#39;, &#39;length&#39;, [
                &#39;rule&#39; =&amp;gt; [&#39;minLength&#39;, 10],
                &#39;message&#39; =&amp;gt; &#39;A name is required&#39;
            ])-&amp;gt;add(&#39;email&#39;, &#39;format&#39;, [
                &#39;rule&#39; =&amp;gt; &#39;email&#39;,
                &#39;message&#39; =&amp;gt; &#39;A valid email address is required&#39;,
            ]);
    }

    // actually send an email
    protected function _execute(array $data)
    {
        $email = new Email(&#39;default&#39;);
        return $email-&amp;gt;from([$data[&#39;email&#39;] =&amp;gt; $data[&#39;name&#39;]])
            -&amp;gt;to(&#39;mail@example.com&#39;, &#39;Mail Example&#39;)
            -&amp;gt;subject(&#39;Contact Form&#39;)
            -&amp;gt;message($data[&#39;body&#39;])
            -&amp;gt;send();
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neato burrito. One thing I love about this is the ability to have complex validation rulesets for specific actions. For instance, on a blog, I might have complex edit action that needs to check for editing writes before allowing a user to do anything:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Form;

use Cake\Form\Form;

class PostEditForm
{
    protected $_user = null;
    public function __construct(array $user = [])
    {
        $this-&amp;gt;_user = $user;
        return $this;
    }

    protected function _buildValidator(Validator $validator)
    {
      // use $this-&amp;gt;_user in my validation rules
      $userId = $this-&amp;gt;_user-&amp;gt;get(&#39;id&#39;);
      $validator-&amp;gt;add(&#39;id&#39;, &#39;custom&#39;, [
          &#39;rule&#39; =&amp;gt; function ($value, $context) use ($userId) {
              // reusing an invokable class
              return (new OwnedByCurrentUser($userId))-&amp;gt;__invoke($value);
          },
          &#39;message&#39; =&amp;gt; &#39;This photo isn\&#39;t yours to battle with&#39;
      ]);
    }
  }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nifty, huh? Usually I end up saving new records in my &lt;code&gt;_execute()&lt;/code&gt; method as well. Here is what that looks like in one of my form classes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;protected function _execute(array $data)
{
    $battle_id = Hash::get($data, &#39;id&#39;, null);
    $photo_id = Hash::get($data, &#39;photo_id&#39;, null);
    $battles = TableRegistry::get(&#39;Battles&#39;);
    $photos = TableRegistry::get(&#39;Photos&#39;);

    $battle = $battles-&amp;gt;find(&#39;Battle&#39;, [
        &#39;battle_id&#39; =&amp;gt; $battle_id,
    ])-&amp;gt;firstOrFail();

    if ($battle-&amp;gt;confirmed != null) {
        throw new MethodNotAllowedException(&#39;Battle has already been updated&#39;);
    }

    $photo = $photos-&amp;gt;get($photo_id);

    $battle-&amp;gt;confirmed = true;
    $battle-&amp;gt;rival-&amp;gt;photo = $photo;
    if ($battles-&amp;gt;save($battle)) {
        return $battles-&amp;gt;find(&#39;Battle&#39;, $battle-&amp;gt;toFind())-&amp;gt;firstOrFail();
    }

    $exception = new ValidationException(&#39;There are errors in the data you submitted&#39;);
    $exception-&amp;gt;errors($battle-&amp;gt;errors());
    throw $exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why? Because it turns certain complex actions into the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function edit()
{
    $authedUser = $this-&amp;gt;Auth-&amp;gt;user();
    $post = (new PostEditForm($authedUser))-&amp;gt;execute($this-&amp;gt;request-&amp;gt;data);
    $this-&amp;gt;set([&#39;post&#39; =&amp;gt; $post]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of litering logic across:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a custom validation method in my model&lt;/li&gt;
  &lt;li&gt;a controller action&lt;/li&gt;
  &lt;li&gt;some other random model method or protected controller method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I can group it all together into one, logical unit that can be easily unit tested for various types of input. A side-benefit of this is that if I &lt;em&gt;absolutely&lt;/em&gt; need to, I can always re-use a given action’s logic with as few as three lines of code within say, idk, a console shell.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/15/stuffing-complex-logic-into-model-less-forms/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/15/stuffing-complex-logic-into-model-less-forms/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>forms</category>
        
        <category>service</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Custom Logging Engines and adding Contextual Data</title>
        <description>&lt;p&gt;Logging is incredibly important, and are very useful for debugging misbehaving applications. CakePHP 3 implements the &lt;a href=&quot;https://github.com/php-fig/log&quot;&gt;PSR-3&lt;/a&gt; logging standard - specifically extending the &lt;a href=&quot;https://github.com/php-fig/log/blob/master/Psr/Log/AbstractLogger.php&quot;&gt;AbstractLogger&lt;/a&gt; - so you have all normal logging levels available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// the `Cake\Log\Log` class holds a log registry,
// so you don&#39;t need to instantiate new loggers constantly
Log::info(&#39;Some info level message&#39;);
Log::error(&#39;uh oh! an error&#39;);

// Swap out to Monolog because you need
// to ship/store logs a specific way
// In your bootstrap:
use Monolog\Logger;
use Monolog\Handler\StreamHandler;

// Configure the logger
Log::config(&#39;default&#39;, function () {
    $log = new Logger(&#39;app&#39;);
    $log-&amp;gt;pushHandler(new StreamHandler(&#39;path/to/your/combined.log&#39;));
    return $log;
});

// Drop unused loggers
Log::drop(&#39;debug&#39;);
Log::drop(&#39;error&#39;);
// and then use it as normal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You’ll notice that a few classes have their own &lt;code&gt;log&lt;/code&gt; methods. You can add this to your own classes using the &lt;code&gt;LogTrait&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App;

use Cake\Log\LogTrait;
class Foo {
  use LogTrait
  public function bar()
  {
    $this-&amp;gt;log(&#39;baz&#39;);
  }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One thing I like doing is having &lt;code&gt;Tagged&lt;/code&gt; logs. That is, I will write a log message like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Message is an entity WUT
// Entities are just bags of data, you can use them however you want
$message = new Message([
  &#39;message&#39; =&amp;gt; &#39;User logged in&#39;,
  &#39;user_id&#39; =&amp;gt; $user-&amp;gt;get(&#39;id&#39;),
  &#39;via&#39; =&amp;gt; &#39;android&#39;
]);

// :boom:
Log::info($message);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CakePHP’s internal formatter will automatically &lt;code&gt;json_encode&lt;/code&gt; any message that is &lt;code&gt;JsonSerializable&lt;/code&gt;. If you also implement a &lt;code&gt;__toString()&lt;/code&gt; method, that will be used instead.&lt;/p&gt;

&lt;p&gt;This is kinda shoddy though, especially needing to manually pass in information that can be inferred through the request. Another method is to pass in that extra data as part of the context of a log message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;Log::info(&#39;User logged in&#39;, [&#39;request&#39; =&amp;gt; $request, &#39;user&#39; =&amp;gt; $user]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this extra data is usually ignored. CakePHP’s internal logging doesn’t have the concept of a formatter - that’s something we’d prefer you use a full logging package like &lt;a href=&quot;https://github.com/Seldaek/monolog&quot;&gt;Monolog&lt;/a&gt; for - but you &lt;em&gt;can&lt;/em&gt; easily implement your own &lt;code&gt;LogEngine&lt;/code&gt; that does what you need. Here is a simple one that simply logs to a file with our extra data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
namespace App\Log\Engine;
use Cake\Log\Engine\FileEngine;
class ContextFileEngine
{
  public function _format($data, $context)
  {
    if (is_string($data)) {
      return $this-&amp;gt;_injectContext($data, $context)
    }

    $object = is_object($data);

    if ($object &amp;amp;&amp;amp; method_exists($data, &#39;__toString&#39;)) {
      $data = (string)$data;
      return $this-&amp;gt;_injectContext($data, $context)
    }

    if ($object &amp;amp;&amp;amp; $data instanceof JsonSerializable) {
      $data = json_decode(json_encode($data), true);
      return $this-&amp;gt;_injectContext($data, $context)
    }

    return $this-&amp;gt;_injectContext(print_r($data, true), $context);
  }

  protected function _injectContext($message, $context)
  {
    $via = null;
    $userId = null;
    if (!empty($context[&#39;request&#39;])) {
      $via = $context[&#39;request&#39;]-&amp;gt;header(&#39;X-Client&#39;);
    }
    if (!empty($context[&#39;user&#39;])) {
      $userId = $context[&#39;user&#39;]-&amp;gt;get(&#39;id&#39;);
    }

    $data = compact(&#39;message&#39;, &#39;via&#39;, &#39;userId&#39;);
    // handle arrays
    if (is_array($message)) {
      $data = $message + compact(&#39;via&#39;, &#39;userId&#39;);
    }

    return parent::_format(json_encode($data), $context);
  }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above will have output similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-12-14 7:55:00 INFO: {&quot;message&quot;: &quot;User logged in&quot;, &quot;userId&quot;: 7, &quot;via&quot;: &quot;android&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method of injecting contextual data into your logs is quite useful for later debugging, and doesn’t require too much extra work around how logs are actually written. Of course, if you need more powerful logging features, I wholeheartedly recommend looking into &lt;a href=&quot;https://github.com/Seldaek/monolog&quot;&gt;Monolog&lt;/a&gt;&lt;br /&gt;
.&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/14/custom-logging-engines-and-adding-contextual-data/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/14/custom-logging-engines-and-adding-contextual-data/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>logging</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>The Collection Class and You</title>
        <description>&lt;p&gt;Many modern applications work on a set of results, iterating over them, manipulating them, and modifying them to display the output necessary to get a job done. In CakePHP 3, we introduced the helpful &lt;code&gt;Collection&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;Here we have an array of cats info:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$cats = [
  [
    &#39;name&#39; =&amp;gt; &#39;camila&#39;,
    &#39;gender&#39; =&amp;gt; &#39;female&#39;,
    &#39;type&#39; =&amp;gt; &#39;calico&#39;,
    &#39;size&#39; =&amp;gt; &#39;small&#39;,
  ],
  [
    &#39;name&#39; =&amp;gt; &#39;railroad&#39;,
    &#39;gender&#39; =&amp;gt; &#39;male&#39;,
    &#39;color&#39; =&amp;gt; &#39;gray&#39;,
    &#39;size&#39; =&amp;gt; &#39;massive&#39;,
  ],
  [
    &#39;name&#39; =&amp;gt; &#39;santo&#39;,
    &#39;gender&#39; =&amp;gt; &#39;male&#39;,
    &#39;color&#39; =&amp;gt; &#39;black&#39;,
    &#39;size&#39; =&amp;gt; &#39;massive&#39;,
  ],
  [
    &#39;name&#39; =&amp;gt; &#39;jax&#39;,
    &#39;gender&#39; =&amp;gt; &#39;male&#39;,
    &#39;color&#39; =&amp;gt; &#39;black&#39;,
    &#39;size&#39; =&amp;gt; &#39;small&#39;,
  ],
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets filter out all the ~~best~~ female cats:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filter the data
$femaleCats = [];
foreach ($cats as $cat) {
  if ($cat[&#39;gender&#39;] == &#39;female&#39;) {
    $femaleCats[] = $cat;
  }
}
// $femaleCats should now contain camila, the cat on your right.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see what this looks like with the Collection class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// instantiate a new collection
$collection = new \Cake\Collection\Collection($cats);

// or use the helper function if you *really* want to
$collection = collection($cats);

// and now filter the data
$femaleCats = $collection-&amp;gt;filter(function ($cat) {
    return $cat[&#39;gender&#39;] == &#39;female;
});

// $femaleCats is a Collection instance that contains one cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats quite a bit simpler, though sometimes you want an array of data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$femaleCats-&amp;gt;toArray();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also chain collection methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$collection
  // get all the small cats
  -&amp;gt;filter(function ($cat) { return $info[&#39;size&#39;] == &#39;small&#39;; })
  // if they are black
  -&amp;gt;filter(function ($cat) { return $info[&#39;color&#39;] == &#39;black&#39;; })
  // if they are female
  -&amp;gt;filter(function ($cat) { return $info[&#39;gender&#39;] == &#39;female&#39;; })
  // and sort alphabetically by name descending
  -&amp;gt;sortBy(&#39;name&#39;, SORT_DESC);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty neat. Collections can work on any &lt;code&gt;array&lt;/code&gt; or instance that implements the &lt;code&gt;Traversable&lt;/code&gt; interface. In CakePHP, you can use any Collection method on the &lt;code&gt;ResultSet&lt;/code&gt; object returned by a query, which is pretty powerful for making complex find methods.&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/13/collections-class-and-you/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/13/collections-class-and-you/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>collections</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Using DSNs to simplify connection strings</title>
        <description>&lt;p&gt;In CakePHP 3, we consolidated most configuration into a single &lt;code&gt;config/app.php&lt;/code&gt;. This superscedes the old method of changing your &lt;code&gt;config/core.php&lt;/code&gt; and &lt;code&gt;config/database.php&lt;/code&gt; - as well as any other random configuration values you might set. This is good for a lot of reasons - who wants to deal with a &lt;code&gt;DATABASE_CONFIG&lt;/code&gt;? - but also means we can simplify how we configure things.&lt;/p&gt;

&lt;p&gt;One thing that always irked me was the inability to specify connection information in a single way. For instance, you might specify the host for a datastore with the following keys:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;host&lt;/code&gt;: For databases&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;server&lt;/code&gt;: For a redis caching server&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;servers&lt;/code&gt;: For memcached servers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One of quite a few different ways configuring CakePHP was yuck. A nice improvement in CakePHP 3 is the ability to specify connection information via a Data source name (DSN).&lt;/p&gt;

&lt;p&gt;A DSN is a standard used by many programming communities to encode all the information about a particular configuration. For instance, here is how I might tell you to connect to my local &lt;code&gt;test&lt;/code&gt; database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$dsn = &quot;mysql://root:cakeisali3@localhost:3306/test&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above encodes the following information:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;scheme&lt;/code&gt;: &lt;code&gt;mysql&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;user&lt;/code&gt;: &lt;code&gt;root&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;password&lt;/code&gt;: &lt;code&gt;cakeisali3&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;host&lt;/code&gt;: &lt;code&gt;localhost&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;port&lt;/code&gt;: &lt;code&gt;3306&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;database&lt;/code&gt;: &lt;code&gt;test&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also specify optional arguments via querystring:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$dsn = &quot;mysql://root:cakeisali3@localhost:3306/test?encoding=utf8&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In 3.x, the following can now use a special &lt;code&gt;url&lt;/code&gt; key. This key will be parsed and it’s values will be used to connect to a database. The following classes can be configured via dsn:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Database connections&lt;/li&gt;
  &lt;li&gt;Cache connections&lt;/li&gt;
  &lt;li&gt;Log information&lt;/li&gt;
  &lt;li&gt;Email configuration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also take advantage of this magic parsing by including the &lt;code&gt;\Cake\Core\StaticConfigTrait&lt;/code&gt; trait in your own classes.&lt;/p&gt;

&lt;p&gt;One thing that might be useful would be to extend the default schemes. In CakePHP, we map the &lt;code&gt;scheme&lt;/code&gt; to a particlar namespaced-class in the CakePHP core. You might add a &lt;code&gt;Mongo&lt;/code&gt;-based ORM Driver, but if it isn’t mapped, your app will go boom. You can map one easily though!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;ConnectionManager::dsnClassMap([&#39;console&#39; =&amp;gt; &#39;App\Database\Driver\Mongo&#39;])
// also works on the following classes:
// - Cache::dsnClassMap()
// - Email::dsnClassMap()
// - Log::dsnClassMap()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s a nifty trick I think, and one that should prove useful to anyone using cloud-providers such as &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt; or &lt;a href=&quot;http://dokku.viewdocs.io/dokku/&quot;&gt;Dokku&lt;/a&gt; for application deployment.&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/12/using-dns-to-simplify-connection-strings/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/12/using-dns-to-simplify-connection-strings/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>dsn</category>
        
        <category>config</category>
        
        
        <category>cakephp</category>
        
      </item>
    
  </channel>
</rss>
